= RISC-V Vector Extension Intrinsic API Reference Manual
:doctype: article
:encoding: utf-8
:lang: en
:toc: left
:numbered:
:stem: latexmath
:le: &#8804;
:ge: &#8805;
:ne: &#8800;
:approx: &#8776;
:inf: &#8734;

:sectnums!:

:sectnums:

== Introduction

These C intrinsic targets the https://github.com/riscv/riscv-v-spec/tree/master[RISC-V "V" Vector Extension].
This document states usage and detail of the RVV intrinsics' and its
programming model. Naming rules and special cases will be covered. Please go to
link:examples[repository="riscv-non-isa/rvv-intrinsic-doc", branch="master", mode="view", link-window="_blank", server="https://www.github.com/"]
for more.

== Types in RVV C Instrinsic

The RVV C intrinsic are strongly-typed, providing a higher level interface
than the RVV instructions. The types imply the SEW and LMUL used in
for the data and can not be implicitly converted.

=== Vector Type

A non-mask vector type encodes the `TYPE` along with `LMUL`. Some fractional
`LMUL` are not supported for longer element widths. The available vector types
are listed here.

[cols="1,1,1,1,1,1,1,1"]
[%autowidth, options="header"]
|===
| Types     | LMUL = 1 | LMUL = 2 | LMUL = 4 | LMUL = 8 | LMUL = 1/2 | LMUL = 1/4 | LMUL = 1/8
| `int64`   | `vint64m1_t`   | `vint64m2_t`   | `vint64m4_t`   | `vint64m8_t`   | N/A             | N/A             | N/A
| `uint64`  | `vuint64m1_t`  | `vuint64m2_t`  | `vuint64m4_t`  | `vuint64m8_t`  | N/A             | N/A             | N/A
| `int32`   | `vint32m1_t`   | `vint32m2_t`   | `vint32m4_t`   | `vint32m8_t`   | `vint32mf2_t`   | N/A             | N/A
| `uint32`  | `vuint32m1_t`  | `vuint32m2_t`  | `vuint32m4_t`  | `vuint32m8_t`  | `vuint32mf2_t`  | N/A             | N/A
| `int16`   | `vint16m1_t`   | `vint16m2_t`   | `vint16m4_t`   | `vint16m8_t`   | `vint16mf2_t`   | `vint16mf4_t`   | N/A
| `uint16`  | `vuint16m1_t`  | `vuint16m2_t`  | `vuint16m4_t`  | `vuint16m8_t`  | `vuint16mf2_t`  | `vuint16mf4_t`  | N/A
| `int8`    | `vint8m1_t`    | `vint8m2_t`    | `vint8m4_t`    | `vint8m8_t`    | `vint8mf2_t`    | `vint8mf4_t`    | `vint8mf8_t`
| `uint8`   | `vuint8m1_t`   | `vuint8m2_t`   | `vuint8m4_t`   | `vuint8m8_t`   | `vuint8mf2_t`   | `vuint8mf4_t`   | `vuint8mf8_t`
| `float64` | `vfloat64m1_t` | `vfloat64m2_t` | `vfloat64m4_t` | `vfloat64m8_t` | N/A             | N/A             | N/A
| `float32` | `vfloat32m1_t` | `vfloat32m2_t` | `vfloat32m4_t` | `vfloat32m8_t` | `vfloat32mf2_t` | N/A             | N/A
| `float16` | `vfloat16m1_t` | `vfloat16m2_t` | `vfloat16m4_t` | `vfloat16m8_t` | `vfloat16mf2_t` | `vfloat16mf4_t` | N/A
|===

=== Mask Type

Length of a mask vector value in RVV will never exceed a single vector
register. The mask vector type encodes the ratio of `SEW` / `LMUL` into the
types. (N = `SEW` / `LMUL`)

[cols="1,1,1,1,1,1,1,1"]
[%autowidth, options="header"]
|===
| Types | N = 1      | N = 2      | N = 4      | N = 8      | N = 16      | N = 32      | N = 64
| bool  | `vbool1_t` | `vbool2_t` | `vbool4_t` | `vbool8_t` | `vbool16_t` | `vbool32_t` | `vbool64_t`
|===

== Naming Rules

Intrinsics is the interface to the low level assembly in high level programming
language. The intrinsic API has the goal to make all the V-ext instructions
accessible from C/C++. The intrinsic names are as close as the assembly
mnemonics. Besides the basic intrinsics corresponding to assembly mnemonics,
there are other intrinsics that do not map to a single instruction in RVV,
they are named to remain close to the action taken.

The intrinsic names will encode return type if it is appropriate. It is easier
to know the output type of the intrinsics from the name. In addition, if the
intrinsic call is used as the operand, having the return type is more immediate.
If there is no return value, the intrinsics will encode the input value types.
If the return type is the same, use exceptional rules to differentiate them,
please refer to section <<naming-exception>>.

```cpp
INTRINSIC ::= MNEMONIC '_' RET_TYPE
MNEMONIC ::= Instruction name in v-ext specification, replacing '.' with '_'.
RET_TYPE ::= SEW LMUL
SEW ::= ( i8 | i16 | i32 | i64 | u8 | u16 | u32 | u64 | f16 | f32 | f64 )
LMUL ::= ( m1 | m2 | m4 | m8 | mf2 | mf4 | mf8 )

Example:

vadd.vv vd, vs2, vs1
vint8m1_t vadd_vv_i8m1(vint8m1_t vs2, vint8m1_t vs1, size_t vl);

vwaddu.vv vd, vs2, vs1
vint16m2_t vwaddu_vv_i16m2(vint8m1_t vs2, vint8m1_t vs1, size_t vl);
```

[[naming-exception]]
=== Exception In Namings

If intrinsics have the same return type under different input types, we can
not use general naming rules directly on these intrinsics because this will
cause collision between these intrinsics. Therefore there are exception rules
for these special cases. The rules are enumerated here.

==== Vector Store Instructions

The return type of the instructions is `void`. So the data type
stored will be encoded to the intrinsics.

```cpp
Example:

vse8.v vs3, (rs1)
void vse8_v_i8m1 (int8_t *base, vint8m1_t value, size_t vl);
void vse8_v_u8m1 (uint8_t *base, vuint8m1_t value, size_t vl);
```

==== Vector Comparison Instructions

The instructions return a mask type. So the input type will be encoded to the
intrinsics.

```cpp
Example:

vmseq.vv vd, vs2, vs1
vbool8_t vmseq_vv_i8m1_b8 (vint8m1_t op1, vint8m1_t op2, size_t vl);
vbool16_t vmseq_vv_i16m1_b16 (vint16m1_t op1, vint16m1_t op2, size_t vl);
```

==== Vector Reduction Instructions

The instructions' scalar output are held in the 0th element of a single vector
register using LMUL = 1 in the return vector type. So the input type will be
encoded in the intrinsics.

```cpp
Example:

vredsum.vs vd, vs2, vs1
vint8m1_t vredsum_vs_i8m1_i8m1 (vint8m1_t dest, vint8m1_t vector, vint8m1_t scalar, size_t vl);
vint8m1_t vredsum_vs_i8m2_i8m1 (vint8m1_t dest, vint8m2_t vector, vint8m1_t scalar, size_t vl);
```

==== Vector Scalar Move Instructions

The instructions' return a scalar value. So the input type will be encoded in
the intrinsics.

```cpp
Example:

vmv.x.s rd, vs2
int8_t vmv_x_s_i8m1_i8 (vint8m1_t src);
int8_t vmv_x_s_i8m2_i8 (vint8m2_t src);
```

==== `vcpop` and `vfirst`

The instructions return a scalar value. So the input type will be encoded in
the intrinsics.

```cpp
Example:

vcpop.m rd, vs2
unsigned long vcpop_m_b1 (vbool1_t op1, size_t vl);
unsigned long vcpop_m_b2 (vbool2_t op1, size_t vl);

vfirst.m rd, vs2, vm
long vfirst_m_b1 (vbool1_t op1, size_t vl);
long vfirst_m_b2 (vbool2_t op1, size_t vl);
```

==== `vmadc` and `vmsbc`

The instructions return a mask type. So the input type will be encoded to the
intrinsics.

```cpp
Example:

vmadc.vv vd, vs2, vs1 

vbool8_t vmadc_vv_i8m1_b8 (vint8m1_t op1, vint8m1_t op2, size_t vl);
vbool8_t vmadc_vv_i16m2_b8 (vint16m2_t op1, vint16m2_t op2, size_t vl);

vmsbc.vvm vd, vs2, vs1, v0
vbool8_t vmsbc_vvm_i8m1_b8 (vint8m1_t op1, vint8m1_t op2, vbool8_t borrowin, size_t vl);
vbool8_t vmsbc_vvm_i16m2_b8 (vint16m2_t op1, vint16m2_t op2, vbool8_t borrowin, size_t vl);
```

== Configuration and Utility Functions

=== Vector Length-Related Functions

This chapter corresponds to configuration instructions `vsetvl`, `vsetvli` and
`vsetivli`. The following functions is called to obtain vector length and used
as input parameter for other C intrisic functions that performs actual
computation. Calling this function won't trigger rvv configuration
instructions. The configuration instructions will be triggered when `vl` is
passed as parameters into other C intrinsic API-s.

==== `vsetvlmax`

The functions return the maximum number of elements to process for the later
vector instruction(s), given the `SEW` and `LMUL`. (VLMAX = VLEN * LMUL / SEW,
please refer to https://github.com/riscv/riscv-v-spec/blob/master/v-spec.adoc#34-vector-type-register-vtype[v-spec : 3.4. Vector type register, `vtype`].

The intrinsic functions are in the format below, with `e{SEW}m{LMUL}`
encoding a valid vector type.

```cpp
size_t vsetvlmax_e{SEW}m{LMUL}();

Example:
size_t vsetvlmax_e64m1 ();
```

==== `vsetvl`

The functions return the number of elements to process for the later vector
instructions, given `SEW`, `LMUL` and `avl` (available vector length).

The intrinsic functions are in the format below, with `e{SEW}m{LMUL}`
encoding a valid vector type.

```cpp
size_t vsetvl_e{SEW}m{LMUL}(size_t avl);

Example:
size_t vsetvlmax_e32m1 ();
```

=== Reinterpret Cast Conversion Functions

The functions reinterpret the contents of a data as a different type under the
same SEW/LMUL.

```cpp
RETURN_VEC_TYPE vreinterpret_v_{INPUT_VEC_SHORT_TYPE}_{RETURN_VEC_SHORT_TYPE} (INPUT_VEC_TYPE src);

Example:
vfloat16m1_t vreinterpret_v_i16m1_f16m1 (vint16m1_t src);
```

=== Vector Initialization Functions

The functions returns a placeholding vector type.  The data within the vector
type is undefined and unpredictable. The only recommended usage for these
functions is to use them as `maskedoff` operand to trigger the agnostic policy.

```cpp
RETURN_VEC_TYPE vundefined_{RETURN_VEC_SHORT_TYPE} ();

Example:
vint32m1_t vundefined_i32m1 ();
```

NOTE: e.g. `vxor(vundefined(), vundefined())` and `vec a = vundefined(); vec b = vxor(a, a);`
both don't guarantee result vector with all zeros.

=== Vector LMUL Extension and Truncation Functions

These utility functions help users to truncate or extent current LMUL
under same SEW regardless of vl, it won't change content of vl register.
The LMUL extension result of extension part are undefined value.

```cpp
RETURN_VEC_TYPE vlmul_trunc_v_{INPUT_VEC_SHORT_TYPE}_{RETURN_VEC_SHORT_TYPE} (INPUT_VEC_TYPE op1);

Example:
vint64m1_t vlmul_trunc_v_i64m2_i64m1 (vint64m2_t op1);

RETURN_VEC_TYPE vlmul_ext_v_{INPUT_VEC_SHORT_TYPE}_{RETURN_VEC_SHORT_TYPE} (INPUT_VEC_TYPE op1);

Example:
vint64m2_t vlmul_ext_v_i64m1_i64m2 (vint64m1_t op1);
```

=== Read / Write to vector CSRs

Please refer to v-spec: https://github.com/riscv/riscv-v-spec/blob/master/v-spec.adoc#vector-extension-programmers-model[3. Vector Extension Programmerâ€™s Model]
for definitions and usages of the CSRs.

```cpp
enum RVV_CSR {
  RVV_VSTART = 0,
  RVV_VXSAT,
  RVV_VXRM,
  RVV_VCSR,
};

unsigned long vread_csr(enum RVV_CSR csr);
void vwrite_csr(enum RVV_CSR csr, unsigned long value);
```
